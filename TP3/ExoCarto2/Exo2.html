<!DOCTYPE html>

<html>

<head>
    <title>Exercice 2</title>
    <script type="text/javascript" src="three.js"></script>

    <style>
      body {
	background-color: #000;
	margin: 0px;
	overflow: hidden;
}

    </style>
</head>
<body>

<script >

var mesh, renderer, scene, camera, controls;

var lastMouseDown = new THREE.Vector3();
var mouseDownCameraPosition = new THREE.Vector3();
var dragging = false;

init();
animate();

function init() {

    // renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( 0x889988 );
    document.body.appendChild( renderer.domElement );

    // scene
    scene = new THREE.Scene();
    
    // camera
    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 20, 20, 20 );
    camera.lookAt(0,0,0);
    scene.add( camera ); // required, since adding light as child of camera
    
    // ambient
    scene.add( new THREE.AmbientLight( 0x444444 ) );
    
    // light
    var light = new THREE.PointLight( 0xffffff, 0.8 );
    camera.add( light );
    
    // axes
    //scene.add( new THREE.AxisHelper( 20 ) );

    // geometry
    var geometry = new THREE.BoxGeometry( 4, 2, 2 );
    
    // material
    var material1 = new THREE.MeshPhongMaterial( {
        color: '#00bfff'
    } );
    
    // mesh
    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.set( 2, - 4, 6 );
    scene.add( mesh );

    // geometry
    var geometry = new THREE.BoxGeometry( 2, 2, 2 );
    
    // material
    var material1 = new THREE.MeshPhongMaterial( {
        color: '#a52a2a'
    } );
    
    // mesh
    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.set( -2 , - 4, - 6 );
    scene.add( mesh );

    // geometry
    var geometry = new THREE.BoxGeometry( 20, 10, 20 );
    
    // material
    var material1 = new THREE.MeshPhongMaterial( {
        color: '#00ff00', 
        transparent: true,
        opacity: 0.1
    } );
    
    // mesh
    mesh = new THREE.Mesh( geometry, material1 );
    scene.add( mesh );
    
    // material
    var material2 = new THREE.MeshPhongMaterial( {
        color:'0xffffff', 
        transparent: false,
        side: THREE.BackSide
    } );
    
    // mesh
    mesh = new THREE.Mesh( geometry, material2 );
    scene.add( mesh );
    
    document.addEventListener( 'mousedown', onDocumentMouseDown, false );
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
}

function onDocumentMouseDown( event ) {
  event.preventDefault();
  
  var mouseScreenPos = new THREE.Vector3();

  mouseScreenPos.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouseScreenPos.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  var rayOrigin = (new THREE.Vector3(mouseScreenPos.x, mouseScreenPos.y, 0.0)).unproject(camera);
  var rayPos1 = (new THREE.Vector3(mouseScreenPos.x, mouseScreenPos.y, 1.0)).unproject(camera);
  var rayDirection = rayPos1.sub(rayOrigin);
  
  lastMouseDown = rayIntersectionWithXZPlane(rayOrigin, rayDirection, -5.0);
  mouseDownCameraPosition = camera.position;
  dragging = true;
  
  console.log(lastMouseDown);
}

function onDocumentMouseMove() {
 	if (!dragging) return;
  
  var mouseScreenPos = new THREE.Vector3();

	mouseScreenPos.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouseScreenPos.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  var rayOrigin = (new THREE.Vector3(mouseScreenPos.x, mouseScreenPos.y, 0.0)).unproject(camera);
  var rayPos1 = (new THREE.Vector3(mouseScreenPos.x, mouseScreenPos.y, 1.0)).unproject(camera);
  var rayDirection = rayPos1.sub(rayOrigin);
  
  var newMouseDown = rayIntersectionWithXZPlane(rayOrigin, rayDirection, -5.0);
  
  camera.position = mouseDownCameraPosition.sub(newMouseDown.sub(lastMouseDown));
  console.log(newMouseDown.sub(lastMouseDown));
}

function onDocumentMouseUp() {
	dragging = false;
}

function rayIntersectionWithXZPlane(rayOrigin, rayDirection, planeY)
{
	var ySlope = (planeY - rayOrigin.y) / rayDirection.y;
	var xIntersect = rayDirection.x * ySlope + rayOrigin.x;
  var zIntersect = rayDirection.z * ySlope + rayOrigin.z;
  
  return new THREE.Vector3(xIntersect, planeY, zIntersect);
}

function animate() {

  requestAnimationFrame( animate );

  renderer.render( scene, camera );
}

</script>
</body>
</html>